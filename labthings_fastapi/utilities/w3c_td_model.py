# This file was generated by `datamodel-code-generator`, using
# the command
# datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py
# I then manually simplified it a bit, mostly by deduplicating/using inheritance.

from __future__ import annotations

import logging
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union, TypeVar, Generic, Mapping, Literal

from pydantic import AnyUrl, BaseModel, Extra, Field, conint, root_validator, RootModel

class Version(BaseModel):
    instance: str


AnyUri = RootModel[str]
Description = RootModel[str]
Descriptions = RootModel[Optional[Dict[str, str]]]
Title = RootModel[str]
Titles = RootModel[Optional[Dict[str, str]]]
Security = RootModel[Union[List[str], str]]
Scopes = RootModel[Union[List[str], str]]
TypeDeclaration = RootModel[Union[str, List[str]]]


class Subprotocol(Enum):
    longpoll = 'longpoll'
    websub = 'websub'
    sse = 'sse'

THING_CONTEXT_LITERAL = Literal['https://www.w3.org/2019/wot/td/v1']
THING_CONTEXT_URL = THING_CONTEXT_LITERAL.__args__[0]


class ThingContext(RootModel):
    root: Union[List[Union[AnyUri, Dict[str, Any]]], THING_CONTEXT_LITERAL]


class Type(Enum):
    boolean = 'boolean'
    integer = 'integer'
    number = 'number'
    string = 'string'
    object = 'object'
    array = 'array'
    null = 'null'


class DataSchema(BaseModel):
    field_type: Optional[TypeDeclaration] = Field(None, alias='@type')
    description: Optional[Description] = None
    title: Optional[Title] = None
    descriptions: Optional[Descriptions] = None
    titles: Optional[Titles] = None
    writeOnly: Optional[bool] = None
    readOnly: Optional[bool] = None
    oneOf: Optional[list[DataSchema]] = None
    unit: Optional[str] = None
    enum: Optional[list] = None   # was: Field(None, min_items=1, unique_items=True) but this failed with generic models
    format: Optional[str] = None
    const: Optional[Any] = None
    default: Optional[Any] = None
    type: Optional[Type] = None
    # The fields below should be empty unless type==Type.array
    items: Optional[Union[DataSchema, List[DataSchema]]] = None
    maxItems: Optional[conint(ge=0)] = None
    minItems: Optional[conint(ge=0)] = None
    # The fields below should be empty unless type==Type.number or Type.integer
    minimum: Optional[Union[int, float]] = None
    maximum: Optional[Union[int, float]] = None
    exclusiveMinimum: Optional[Union[int, float]] = None
    exclusiveMaximum: Optional[Union[int, float]] = None
    multipleOf: Optional[Union[int, float]] = None
    # The fields below should be empty unless type==Type.object
    properties: Optional[Mapping[str, DataSchema]] = None
    required: Optional[list[str]] = None
    # The fields below should be empty unless type==Type.string
    minLength: Optional[int] = None
    maxLength: Optional[int] = None
    pattern: Optional[str] = None
    contentEncoding: Optional[str] = None
    contentMediaType: Optional[str] = None

    class Config:
        extra = Extra.forbid

"""
# The classes below attempted to implement the w3c spec for type-specific fields.
# However, this is very hard without complicated logic - and the w3c JSONSchema
# simply defines one DataSchema type, as I have done above.
# The code below almost but not quite works.

class ArraySchema(DataSchema):
    type: Type = Literal[Type.array]
    items: Optional[Union[DataSchema, List[DataSchema]]] = None
    maxItems: Optional[conint(ge=0)] = None
    minItems: Optional[conint(ge=0)] = None


numberT = TypeVar("numberT", int, float)
class GenericNumberSchema(DataSchema, BaseModel, Generic[numberT]):
    minimum: Optional[numberT] = None
    maximum: Optional[numberT] = None
    exclusiveMinimum: Optional[numberT] = None
    exclusiveMaximum: Optional[numberT] = None
    multipleOf: Optional[numberT] = None


class NumberSchema(GenericNumberSchema[float]):
    type: Type = Literal[Type.number]


class IntegerSchema(GenericNumberSchema[int]):
    type: Type = Literal[Type.integer]
    

class BooleanSchema(DataSchema):
    type: Type = Literal[Type.boolean]


class ObjectSchema(DataSchema):
    type: Type = Literal[Type.object]
    properties: Optional[Mapping[str, DataSchema]] = None
    required: Optional[List[str]] = None


class StringSchema(DataSchema):
    type: Type = Literal[Type.string]
    minLength: Optional[int] = None
    maxLength: Optional[int] = None
    pattern: Optional[str] = None
    contentEncoding: Optional[str] = None
    contentMediaType: Optional[str] = None


class NullSchema(DataSchema):
    type: Type = Literal[Type.object]


DataSchema: Type = Union[
    DataSchema, 
    ArraySchema,
    BooleanSchema,
    IntegerSchema,
    NullSchema,
    NumberSchema,
    ObjectSchema,
    StringSchema,
]


DATA_SCHEMA_MODELS: list[BaseModel] = [
    DataSchema, 
    ArraySchema,
    BooleanSchema,
    IntegerSchema,
    NullSchema,
    NumberSchema,
    ObjectSchema,
    StringSchema,
]
for model in DATA_SCHEMA_MODELS:
    model.update_forward_refs()
"""

class Response(BaseModel):
    contentType: Optional[str] = None


class PropertyOp(Enum):
    readproperty = 'readproperty'
    writeproperty = 'writeproperty'
    observeproperty = 'observeproperty'
    unobserveproperty = 'unobserveproperty'


class ActionOp(Enum):
    invokeaction = 'invokeaction'


class EventOp(Enum):
    subscribeevent = 'subscribeevent'
    unsubscribeevent = 'unsubscribeevent'


class RootOp(Enum):
    readallproperties = 'readallproperties'
    writeallproperties = 'writeallproperties'
    readmultipleproperties = 'readmultipleproperties'
    writemultipleproperties = 'writemultipleproperties'


Op = Union[PropertyOp, ActionOp, EventOp, RootOp]


OpT = TypeVar("OpT")


class Form(BaseModel, Generic[OpT]):
    class Config:
        extra = Extra.allow

    href: AnyUri
    op: Optional[Union[OpT, List[OpT]]] = None
    contentType: Optional[str] = None
    contentCoding: Optional[str] = None
    subprotocol: Optional[Subprotocol] = None
    security: Optional[Security] = None
    scopes: Optional[Scopes] = None
    response: Optional[Response] = None


class InteractionAffordance(BaseModel):
    class Config:
        extra = Extra.allow

    description: Optional[Description] = None
    descriptions: Optional[Descriptions] = None
    title: Optional[Title] = None
    titles: Optional[Titles] = None
    forms: List[Form[Op]] = Field(..., min_items=1)
    uriVariables: Optional[Dict[str, DataSchema]] = None


class PropertyAffordance(InteractionAffordance, DataSchema):
    observable: Optional[bool] = None
    forms: List[Form[PropertyOp]] = Field(..., min_items=1)


class ActionAffordance(InteractionAffordance):
    field_type: Optional[TypeDeclaration] = Field(None, alias='@type')
    input: Optional[DataSchema] = None
    output: Optional[DataSchema] = None
    safe: Optional[bool] = None
    idempotent: Optional[bool] = None
    forms: List[Form[ActionOp]] = Field(..., min_items=1)


class EventAffordance(BaseModel):
    field_type: Optional[TypeDeclaration] = Field(None, alias='@type')
    subscription: Optional[DataSchema] = None
    data: Optional[DataSchema] = None
    cancellation: Optional[DataSchema] = None
    forms: List[Form[EventOp]] = Field(..., min_items=1)


class LinkElement(BaseModel):
    class Config:
        extra = Extra.allow

    href: AnyUri
    type: Optional[str] = None
    rel: Optional[str] = None
    anchor: Optional[AnyUri] = None


class SecuritySchemeEnum(Enum):
    nosec = 'nosec'    # was Scheme
    basic = 'basic'    # was Scheme1
    digest = 'digest'  # was Scheme2
    apikey = 'apikey'  # was Scheme3
    bearer = 'bearer'  # was Scheme4
    psk = 'psk'        # was Scheme5
    oauth2 = 'oauth2'  # was Scheme6


class In(Enum):
    header = 'header'
    query = 'query'
    body = 'body'
    cookie = 'cookie'


class Qop(Enum):
    auth = 'auth'
    auth_int = 'auth-int'


class Flow(Enum):
    code = 'code'


class BaseSecurityScheme(BaseModel):
    field_type: Optional[TypeDeclaration] = Field(None, alias='@type')
    description: Optional[Description] = None
    descriptions: Optional[Descriptions] = None
    proxy: Optional[AnyUri] = None
    scheme: SecuritySchemeEnum


class NoSecurityScheme(BaseSecurityScheme):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.nosec]
    description: Optional[Description] = Description("No security")  # TODO: check if this needs a default factory


class NameAndIn(BaseModel):
    in_: Optional[In] = Field(None, alias='in')  # for scheme=basic,digest,apikey,bearer
    name: Optional[str] = None                   # for scheme=basic,digest,apikey,bearer

class BasicSecurityScheme(BaseSecurityScheme, NameAndIn):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.basic]

class DigestSecurityScheme(BaseSecurityScheme, NameAndIn):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.digest]
    qop: Optional[Qop] = None                    # for scheme=digest

class APISecurityScheme(BaseSecurityScheme, NameAndIn):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.apikey]

class BearerSecurityScheme(BaseSecurityScheme, NameAndIn):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.bearer]
    authorization: Optional[AnyUri] = None       # for scheme=bearer,oauth2
    alg: Optional[str] = None                    # for scheme=bearer
    format: Optional[str] = None                 # for scheme=bearer

class PskSecurityScheme(BaseSecurityScheme):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.psk]
    identity: Optional[str] = None               # for scheme=psk

class Oauth2SecurityScheme(BaseSecurityScheme):
    scheme: SecuritySchemeEnum = Literal[SecuritySchemeEnum.oauth2]
    authorization: Optional[AnyUri] = None       # for scheme=bearer,oauth2
    token: Optional[AnyUri] = None               # for schema=oauth2
    refresh: Optional[AnyUri] = None             # for scheme=oauth2
    scopes: Optional[Union[List[str], str]] = None  # oauth2
    flow: Optional[Flow] = None                  # for scheme=oauth2


SecurityScheme = Union[
    BaseSecurityScheme,
    NoSecurityScheme,
    BasicSecurityScheme,
    DigestSecurityScheme,
    APISecurityScheme,
    BearerSecurityScheme,
    PskSecurityScheme,
    Oauth2SecurityScheme,
]


class WotTdSchema16October2019(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[AnyUrl] = None
    title: Title
    titles: Optional[Titles] = None
    properties: Optional[Dict[str, PropertyAffordance]] = None
    actions: Optional[Dict[str, ActionAffordance]] = None
    events: Optional[Dict[str, EventAffordance]] = None
    description: Optional[Description] = None
    descriptions: Optional[Descriptions] = None
    version: Optional[Version] = None
    links: Optional[List[LinkElement]] = None
    forms: Optional[List[Form[RootOp]]] = Field(None, min_items=1)
    base: Optional[AnyUri] = None
    securityDefinitions: Dict[str, SecurityScheme]
    support: Optional[AnyUri] = None
    created: Optional[datetime] = None
    modified: Optional[datetime] = None
    security: Union[str, List[str]]
    field_type: Optional[TypeDeclaration] = Field(None, alias='@type')
    field_context: ThingContext = Field(ThingContext(THING_CONTEXT_URL), alias='@context')

ThingDescription = WotTdSchema16October2019
